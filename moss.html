<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>moss</title>
    <style>


        body {
            margin: 0;
            padding: 0;
            background-color: #f5f5dc;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        
        .canvas-container {
            position: relative;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        canvas {
            border: 1px solid #ddd;
            display: block; 
        }
        
        #regenerate-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 10;
            padding: 10px 15px;
            font-family: sans-serif;
            font-size: 14px;
            cursor: pointer;
            background-color: #e6e6c1;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: background-color 0.2s;
        }
        #regenerate-btn:hover {
            background-color: #a2c9a1;
        }
        .title-image {
            position: absolute;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            
            /* Adjust width as needed, height will scale automatically */
            width: 350px; 
            
            /* Makes the image non-interactive so you can click through it */
            pointer-events: none; 
            z-index: 20;
        }

        
    </style>
</head>
<body>
    <div class="canvas-container">
        <canvas id="tower"></canvas>
        <button id="regenerate-btn">Regenerate</button>
    </div>
    <img src="moss-title.png" alt="moss title" class="title-image">
    <script>
        // Canvas setup
        const canvas = document.getElementById('tower');
        const ctx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 900;
        
        // Tower configuration
        const config = {
            baseY: canvas.height-200,
            centerX: canvas.width / 2,
            growthSpeed: 0.03,
            maxHeight: canvas.height * 0.90,
            primaryLineWidth: 3,
            secondaryLineWidth: 0.5,
            primaryColor: '#074D07',
            secondaryColor: 'rgba(7, 77, 7, 0.3)',
            nodeRadius: 4,
            branchProbability: 0.07,
            weaveDensity: 0.7,
            animationSpeed: 0.001,
            maxNodes: 777
        };
        
        // Node class for skeletal structure
        class Node {
            constructor(x, y, parent = null) {
                this.x = x;
                this.y = y;
                this.parent = parent;
                this.children = [];
                this.age = 0;
                this.maxAge = Math.random() * 150 + 80;
                this.growthRate = Math.random() * 0.5 + 0.5;
                this.angle = parent ? parent.angle + (Math.random() - 0.5) * Math.PI / 4 : -Math.PI / 2;
                this.thickness = parent ? parent.thickness * 0.92 : config.primaryLineWidth;
                this.weaveNodes = [];
                this.hasBranched = false;
            }
            
            grow(nodeCount) {
                if (this.age >= this.maxAge || this.y <= canvas.height - config.maxHeight) {
                    return;
                }
                this.age += config.growthSpeed * this.growthRate;
                const wobble = Math.sin(this.age * 0.1) * 0.02;
                this.angle += wobble;
                if (nodeCount >= config.maxNodes) {
                    return;
                }
                if (!this.hasBranched && this.age > this.maxAge * 0.2 && Math.random() < config.branchProbability) {
                    this.branch();
                    this.hasBranched = true;
                }
                if (this.children.length === 0) {
                    const newX = this.x + Math.cos(this.angle) * 2;
                    const newY = this.y + Math.sin(this.angle) * 2;
                    const child = new Node(newX, newY, this);
                    this.children.push(child);
                }
            }
            
            branch() {
                const branchCount = Math.random() < 0.3 ? 2 : 1;
                for (let i = 0; i < branchCount; i++) {
                    const branchAngle = this.angle + (Math.random() - 0.5) * Math.PI / 2;
                    const newX = this.x + Math.cos(branchAngle) * 5;
                    const newY = a.y + Math.sin(branchAngle) * 5;
                    const branch = new Node(newX, newY, this);
                    branch.angle = branchAngle;
                    branch.thickness = this.thickness * 0.7;
                    this.children.push(branch);
                }
            }
            
            generateWeave() {
                if (this.weaveNodes.length < 5 && Math.random() < config.weaveDensity) {
                    const angleOffset = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 20 + 5;
                    this.weaveNodes.push({ x: this.x + Math.cos(angleOffset) * radius, y: this.y + Math.sin(angleOffset) * radius });
                }
            }
            
            draw(ctx, time) {
                if (this.parent) {
                    ctx.strokeStyle = config.primaryColor;
                    ctx.lineWidth = this.thickness * (0.5 + 0.5 * (this.age / this.maxAge));
                    ctx.beginPath();
                    ctx.moveTo(this.parent.x, this.parent.y);
                    const cpX = (this.x + this.parent.x) / 2 + Math.sin(time + this.age) * 5;
                    const cpY = (this.y + this.parent.y) / 2 + Math.cos(time + this.age) * 3;
                    ctx.quadraticCurveTo(cpX, cpY, this.x, this.y);
                    ctx.stroke();
                }
                this.drawWeave(ctx);
                this.children.forEach(child => child.draw(ctx, time));
            }
            
            drawWeave(ctx) {
                ctx.strokeStyle = config.secondaryColor;
                ctx.lineWidth = config.secondaryLineWidth;
                this.weaveNodes.forEach((node, i) => {
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(node.x, node.y);
                    ctx.stroke();
                    this.weaveNodes.forEach((otherNode, j) => {
                        if (i > j && Math.hypot(node.x - otherNode.x, node.y - otherNode.y) < 30) {
                            ctx.beginPath();
                            ctx.moveTo(node.x, node.y);
                            ctx.lineTo(otherNode.x, otherNode.y);
                            ctx.stroke();
                        }
                    });
                });
            }
        }
        
        class Tower {
            constructor() {
                this.roots = [];
                this.time = 0;
                this.initialize();
            }
            
            initialize() {
                const rootCount = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < rootCount; i++) {
                    const x = config.centerX + (Math.random() - 0.5) * 100;
                    this.roots.push(new Node(x, config.baseY));
                }
            }
            
            update() {
                this.time += config.animationSpeed;
                const allNodes = [];
                const queue = [...this.roots];
                while (queue.length > 0) {
                    const currentNode = queue.shift();
                    allNodes.push(currentNode);
                    currentNode.children.forEach(child => queue.push(child));
                }
                const currentNodeCount = allNodes.length;
                allNodes.forEach(node => {
                    node.grow(currentNodeCount);
                    node.generateWeave();
                });
                if (currentNodeCount < config.maxNodes && Math.random() < 0.01 && this.roots.length < 7) {
                    const x = config.centerX + (Math.random() - 0.5) * 150;
                    this.roots.push(new Node(x, config.baseY));
                }
            }
            
            draw(ctx) {
                ctx.fillStyle = '#f5f5dc';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                this.roots.forEach(root => root.draw(ctx, this.time));
                
            }
        }
        
        
        
        let tower; 
        
       
        function restart() {
            tower = new Tower();
        }

        const regenerateButton = document.getElementById('regenerate-btn');
        regenerateButton.addEventListener('click', restart);
        
        function animate() {
            tower.update();
            tower.draw(ctx);
            requestAnimationFrame(animate);
        }
        
        // Initial start of the simulation
        restart();
        animate();

    </script>
</body>
</html>